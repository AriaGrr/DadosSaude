// void inserirArvore(ABB *arvore, Registro *dados)
// {
//   EABB *novo = criaVertice(dados);
//   if (arvore->raiz == NULL)
//   {
//     arvore->raiz = novo;
//   }
//   else
//   {
//     inserirABB(novo, arvore->raiz);
//   }
//   arvore->qtde++;
// }

// void inserirABB(EABB *novo, EABB *raiz)
// {
//   if (novo->dados->entrada->ano < raiz->dados->entrada->ano)
//   {
//     if (raiz->esq == NULL)
//     {
//       raiz->esq = novo;
//     }
//     else
//     {
//       inserirABB(novo, raiz->esq);
//     }
//   }
//   else if (novo->dados->entrada->ano > raiz->dados->entrada->ano)
//   {
//     if (raiz->dir == NULL)
//     {
//       raiz->dir = novo;
//     }
//     else
//     {
//       inserirABB(novo, raiz->dir);
//     }
//   }
//   else
//   {
//     if (novo->dados->entrada->mes < raiz->dados->entrada->mes)
//     {
//       if (raiz->esq == NULL)
//       {
//         raiz->esq = novo;
//       }
//       else
//       {
//         inserirABB(novo, raiz->esq);
//       }
//     }
//     else if (novo->dados->entrada->mes > raiz->dados->entrada->mes)
//     {
//       if (raiz->dir == NULL)
//       {
//         raiz->dir = novo;
//       }
//       else
//       {
//         inserirABB(novo, raiz->dir);
//       }
//     }
//     else
//     {
//       if (novo->dados->entrada->dia < raiz->dados->entrada->dia)
//       {
//         if (raiz->esq == NULL)
//         {
//           raiz->esq = novo;
//         }
//         else
//         {
//           inserirABB(novo, raiz->esq);
//         }
//       }
//       else if (novo->dados->entrada->dia > raiz->dados->entrada->dia)
//       {
//         if (raiz->dir == NULL)
//         {
//           raiz->dir = novo;
//         }
//         else
//         {
//           inserirABB(novo, raiz->dir);
//         }
//       }
//       else
//       {
//         if (novo->dados->idade < raiz->dados->idade)
//         {
//           if (raiz->esq == NULL)
//           {
//             raiz->esq = novo;
//           }
//           else
//           {
//             inserirABB(novo, raiz->esq);
//           }
//         }
//         else if (novo->dados->idade > raiz->dados->idade)
//         {
//           if (raiz->dir == NULL)
//           {
//             raiz->dir = novo;
//           }
//           else
//           {
//             inserirABB(novo, raiz->dir);
//           }
//         }
//         else
//         {
//           printf("Paciente ja cadastrado\n");
//         }
//       }
//     }
//   }
// }


// void mostrarAno(EABB *raiz)
// {
//   if (raiz != NULL)
//   {
//     mostrarAno(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrarAno(raiz->dir);
//   }
// }

// void mostrarMes(EABB *raiz)
// {
//   if (raiz != NULL)
//   {
//     mostrarMes(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrarMes(raiz->dir);
//   }
// }

// void mostrarDia(EABB *raiz)
// {
//   if (raiz != NULL)
//   {
//     mostrarDia(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrarDia(raiz->dir);
//   }
// }

// void mostrarIdade(EABB *raiz)
// {
//   if (raiz != NULL)
//   {
//     mostrarIdade(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrarIdade(raiz->dir);
//   }
// }

// void mostrarArvore(ABB *arvore, int opcao)
// {
//   if (arvore->raiz == NULL)
//   {
//     printf("Arvore vazia\n");
//     return;
//   }
//   if (opcao == 1)
//   {
//     mostrarAno(arvore->raiz);
//   }
//   else if (opcao == 2)
//   {
//     mostrarMes(arvore->raiz);
//   }
//   else if (opcao == 3)
//   {
//     mostrarDia(arvore->raiz);
//   }
//   else if (opcao == 4)
//   {
//     mostrarIdade(arvore->raiz);
//   }
//   else
//   {
//     printf("Opcao invalida\n");
//   }
// }






// // Montar um arquivo json a partir de cada uma das estruturas
// cJSON *estruturaJson1(void *data, const char *campo[], const char *tipo[])
// {
//   // Cria um objeto JSON
//   cJSON *obj = cJSON_CreateObject();

//   // Adiciona os campos ao objeto JSON
//   for (int i = 0; campo[i] != NULL; i++)
//   {
//     // Adiciona um campo do tipo inteiro
//     if (strcmp(tipo[i], "int") == 0)
//     {
//       ADD_FIELD(obj, campo[i], Number, *((int *)data + i));
//     }
//     // Adiciona um campo do tipo string
//     else if (strcmp(tipo[i], "char*") == 0)
//     {
//       ADD_FIELD(obj, campo[i], String, *((char **)data + i));
//     }
//     // Adiciona um campo do tipo Data
//     else if (strcmp(tipo[i], "Data") == 0)
//     {
//       // Pega o ponteiro para a estrutura Data
//       Data *data_ptr = (Data *)((char *)data + i * sizeof(char *));
//       // Cria um objeto JSON para a estrutura Data
//       cJSON *data_obj = cJSON_CreateObject();
//       // Adiciona os campos da estrutura Data ao objeto JSON
//       ADD_FIELD(data_obj, "dia", Number, data_ptr->dia);
//       ADD_FIELD(data_obj, "mes", Number, data_ptr->mes);
//       ADD_FIELD(data_obj, "ano", Number, data_ptr->ano);
//       // Adiciona o objeto JSON da estrutura Data ao objeto JSON principal
//       cJSON_AddItemToObject(obj, campo[i], data_obj);
//     }
//     else
//     {
//       // Tratar outros tipos de dados aqui
//       printf("Tipo de dado não suportado: %s\n", tipo[i]);
//     }
//   }

//   // Retorna o objeto JSON criado
//   return obj;
// }

// // Do mesmo arquivo json, montar a estrutura 
// void jsonEstrutura1(const char *arquivo, void *estrutura, const char *campo[], const char *tipo[])
// {
//   // Abre o arquivo JSON
//   FILE *fp = fopen(arquivo, "r");
//   if (!fp)
//   {
//     perror("Erro ao abrir o arquivo");
//     return;
//   }

//   // Lê o conteúdo do arquivo
//   fseek(fp, 0, SEEK_END);
//   long fsize = ftell(fp);
//   fseek(fp, 0, SEEK_SET);

//   char *jsonString = (char *)malloc(fsize + 1);
//   fread(jsonString, 1, fsize, fp);
//   fclose(fp);
//   jsonString[fsize] = 0;

//   // Analisa o conteúdo do arquivo JSON
//   cJSON *root = cJSON_Parse(jsonString);
//   if (!root)
//   {
//     printf("Erro ao analisar o JSON\n");
//     free(jsonString);
//     return;
//   }

//   // Monta a estrutura de dados a partir do arquivo JSON
//   for (int i = 0; campo[i] != NULL; i++)
//   {
//     cJSON *field = cJSON_GetObjectItem(root, campo[i]);
//     if (!field)
//     {
//       printf("Campo %s não encontrado\n", campo[i]);
//       continue;
//     }

//     // Adiciona o campo à estrutura de dados
//     if (strcmp(tipo[i], "int") == 0)
//     {
//       *((int *)estrutura + i) = field->valueint;
//     }
//     else if (strcmp(tipo[i], "char*") == 0)
//     {
//       *((char **)estrutura + i) = strdup(field->valuestring);
//     }
//     else if (strcmp(tipo[i], "Data") == 0)
//     {
//       Data *data = (Data *)((char *)estrutura + i * sizeof(char *));
//       cJSON *dia = cJSON_GetObjectItem(field, "dia");
//       cJSON *mes = cJSON_GetObjectItem(field, "mes");
//       cJSON *ano = cJSON_GetObjectItem(field, "ano");
//       data->dia = dia->valueint;
//       data->mes = mes->valueint;
//       data->ano = ano->valueint;
//     }
//     else
//     {
//       // Tratar outros tipos de dados aqui
//       printf("Tipo de dado não suportado: %s\n", tipo[i]);
//     }
//   }

//   // Libera a memória alocada
//   cJSON_Delete(root);
//   free(jsonString);
// }



// // jsonEstrutura: Função para montar uma estrutura de dados a partir de um arquivo JSON
// void jsonEstrutura(const char *arquivo, void *estrutura, const char *campo[], const char *tipo[])
// {
//   // Abre o arquivo JSON
//   FILE *fp = fopen(arquivo, "r");
//   if (!fp)
//   {
//     perror("Erro ao abrir o arquivo");
//     return;
//   }

//   // Lê o conteúdo do arquivo
//   fseek(fp, 0, SEEK_END);
//   long fsize = ftell(fp);
//   fseek(fp, 0, SEEK_SET);

//   char *jsonString = (char *)malloc(fsize + 1);
//   fread(jsonString, 1, fsize, fp);
//   fclose(fp);
//   jsonString[fsize] = 0;

//   // Analisa o conteúdo do arquivo JSON
//   cJSON *root = cJSON_Parse(jsonString);
//   if (!root)
//   {
//     printf("Erro ao analisar o JSON\n");
//     free(jsonString);
//     return;
//   }

//   // // Cria a estrutura de dados a partir do arquivo JSON
//   // estruturaJson(estrutura, campo, tipo);

//   // Monta a estrutura de dados a partir do arquivo JSON
//   for (int i = 0; campo[i] != NULL; i++)
//   {
//     cJSON *field = cJSON_GetObjectItem(root, campo[i]);
//     if (!field)
//     {
//       printf("Campo %s não encontrado\n", campo[i]);
//       continue;
//     }

//     // Adiciona o campo à estrutura de dados
//     if (strcmp(tipo[i], "int") == 0)
//     {
//       *((int *)estrutura + i) = field->valueint;
//     }
//     else if (strcmp(tipo[i], "char*") == 0)
//     {
//       *((char **)estrutura + i) = strdup(field->valuestring);
//     }
//     else if (strcmp(tipo[i], "Data") == 0)
//     {
//       Data *data = (Data *)((char *)estrutura + i * sizeof(char *));
//       cJSON *dia = cJSON_GetObjectItem(field, "dia");
//       cJSON *mes = cJSON_GetObjectItem(field, "mes");
//       cJSON *ano = cJSON_GetObjectItem(field, "ano");
//       data->dia = dia->valueint;
//       data->mes = mes->valueint;
//       data->ano = ano->valueint;
//     }
//     else
//     {
//       // Tratar outros tipos de dados aqui
//       printf("Tipo de dado não suportado: %s\n", tipo[i]);
//     }
//   }

//   // Libera a memória alocada
//   cJSON_Delete(root);
//   free(jsonString);
// }

// // estruturaJson: Função para montar um objeto cJSON a partir de uma estrutura de dados genérica
// cJSON *estruturaJson(void *data, const char *campo[], const char *tipo[])
// {
//   // Cria um objeto JSON
//   cJSON *obj = cJSON_CreateObject();

//   // Adiciona os campos ao objeto JSON
//   for (int i = 0; campo[i] != NULL; i++)
//   {
//     // Adiciona um campo do tipo inteiro
//     if (strcmp(tipo[i], "int") == 0)
//     {
//       ADD_FIELD(obj, campo[i], Number, *((int *)data + i));
//     }
//     // Adiciona um campo do tipo string
//     else if (strcmp(tipo[i], "char*") == 0)
//     {
//       ADD_FIELD(obj, campo[i], String, *((char **)data + i));
//     }
//     // Adiciona um campo do tipo Data
//     else if (strcmp(tipo[i], "Data") == 0)
//     {
//       // Pega o ponteiro para a estrutura Data
//       Data *data_ptr = (Data *)((char *)data + i * sizeof(char *));
//       // Cria um objeto JSON para a estrutura Data
//       cJSON *data_obj = cJSON_CreateObject();
//       // Adiciona os campos da estrutura Data ao objeto JSON
//       ADD_FIELD(data_obj, "dia", Number, data_ptr->dia);
//       ADD_FIELD(data_obj, "mes", Number, data_ptr->mes);
//       ADD_FIELD(data_obj, "ano", Number, data_ptr->ano);
//       // Adiciona o objeto JSON da estrutura Data ao objeto JSON principal
//       cJSON_AddItemToObject(obj, campo[i], data_obj);
//     }
//     else
//     {
//       // Tratar outros tipos de dados aqui
//       printf("Tipo de dado não suportado: %s\n", tipo[i]);
//     }
//   }

//   // Retorna o objeto JSON criado
//   return obj;
// }

// void inicializarLista(Lista *lista, const char *arquivo){
//   // Inicializa a lista
//   lista->inicio = NULL;
//   lista->qtde = 0;

//   // Carrega os dados do arquivo JSON
//   jsonEstrutura(arquivo, lista, campos_lista, tipos_lista);
// }

// Funções do menu de cadastro

// // Função para cadastrar um novo paciente
// void cadastrarPaciente(Lista *lista)
// {
//   Registro *novo = (Registro *)malloc(sizeof(Registro));
//   if (!novo)
//   {
//     printf("Erro ao alocar memoria\n");
//     return;
//   }

//   printf("Nome: ");
//   clearBuffer();
//   scanf("%c", &novo->nome);

//   printf("Idade: ");
//   scanf("%d", &novo->idade);

//   printf("RG: ");
//   clearBuffer();
//   scanf("%c", &novo->rg);

//   novo->entrada = (Data *)malloc(sizeof(Data));
//   if (!novo->entrada)
//   {
//     printf("Erro ao alocar memoria\n");
//     return;
//   }

//   printf("Data de entrada (dd/mm/aaaa): ");
//   scanf("%d/%d/%d", &novo->entrada->dia, &novo->entrada->mes, &novo->entrada->ano);

//   ELista *novoNo = (ELista *)malloc(sizeof(ELista));
//   if (!novoNo)
//   {
//     printf("Erro ao alocar memoria\n");
//     return;
//   }

//   novoNo->dados = novo;
//   novoNo->proximo = lista->inicio;
//   lista->inicio = novoNo;
//   lista->qtde++;
// }

// // Função para consultar um paciente cadastrado
// // void consultarPaciente(Lista *lista)
// // {
// //   char nome;
// //   printf("Nome: ");
// //   clearBuffer();
// //   scanf("%c", &nome);

// //   ELista *atual = lista->inicio;
// //   while (atual)
// //   {
// //     if (atual->dados->nome == nome)
// //     {
// //       printf("Nome: %c\n", atual->dados->nome);
// //       printf("Idade: %d\n", atual->dados->idade);
// //       printf("RG: %c\n", atual->dados->rg);
// //       printf("Data de entrada: %02d/%02d/%04d\n", atual->dados->entrada->dia, atual->dados->entrada->mes, atual->dados->entrada->ano);
// //       return;
// //     }
// //     atual = atual->proximo;
// //   }
// //   printf("Paciente nao encontrado\n");
// // }

// // Função consultar paciente cadastrado pelo rg
// void consultarPaciente(Lista *lista)
// {
//   char rg;
//   printf("RG: ");
//   clearBuffer();
//   scanf("%c", &rg);

//   ELista *atual = lista->inicio;
//   while (atual)
//   {
//     if (atual->dados->rg == rg)
//     {
//       printf("Nome: %c\n", atual->dados->nome);
//       printf("Idade: %d\n", atual->dados->idade);
//       printf("RG: %c\n", atual->dados->rg);
//       printf("Data de entrada: %02d/%02d/%04d\n", atual->dados->entrada->dia, atual->dados->entrada->mes, atual->dados->entrada->ano);
//       return;
//     }
//     atual = atual->proximo;
//   }
//   printf("Paciente nao encontrado\n");
// }

// Função para cadastrar um novo paciente
// void cadastrarPaciente(Lista *lista)
// {
//   Registro *novo = (Registro *)malloc(sizeof(Registro));
//   if (!novo)
//   {
//     printf("Erro ao alocar memoria\n");
//     return;
//   }

//   printf("Nome: ");
//   clearBuffer();
//   fgets(novo->nome, 50, stdin);
//   novo->nome[strcspn(novo->nome, "\n")] = 0;

//   printf("Idade: ");
//   scanf("%d", &novo->idade);

//   printf("RG: ");
//   clearBuffer();
//   fgets(novo->rg, 10, stdin);
//   novo->rg[strcspn(novo->rg, "\n")] = 0;

//   novo->entrada = (Data *)malloc(sizeof(Data));
//   if (!novo->entrada)
//   {
//     printf("Erro ao alocar memoria\n");
//     return;
//   }

//   printf("Data de entrada (dd/mm/aaaa): ");
//   scanf("%d/%d/%d", &novo->entrada->dia, &novo->entrada->mes, &novo->entrada->ano);

//   ELista *novoNo = (ELista *)malloc(sizeof(ELista));
//   if (!novoNo)
//   {
//     printf("Erro ao alocar memoria\n");
//     return;
//   }

//   novoNo->dados = novo;
//   novoNo->proximo = lista->inicio;
//   lista->inicio = novoNo;
//   lista->qtde++;
// }

// Função para consultar um paciente cadastrado
// void consultarPaciente(Lista *lista)
// {
//   char nome[50];
//   printf("Nome: ");
//   clearBuffer();
//   fgets(nome, 50, stdin);
//   nome[strcspn(nome, "\n")] = 0;

//   ELista *atual = lista->inicio;
//   while (atual)
//   {
//     if (strcmp(atual->dados->nome, nome) == 0)
//     {
//       printf("Nome: %s\n", atual->dados->nome);
//       printf("Idade: %d\n", atual->dados->idade);
//       printf("RG: %s\n", atual->dados->rg);
//       printf("Data de entrada: %02d/%02d/%04d\n", atual->dados->entrada->dia, atual->dados->entrada->mes, atual->dados->entrada->ano);
//       return;
//     }
//     atual = atual->proximo;
//   }
//   printf("Paciente nao encontrado\n");
// }

// Função consultar paciente cadastrado pelo rg
// void consultarPaciente(Lista *lista)
// {
//   char rg[10];
//   printf("RG: ");
//   clearBuffer();
//   fgets(rg, 10, stdin);
//   rg[strcspn(rg, "\n")] = 0;

//   ELista *atual = lista->inicio;
//   while (atual)
//   {
//     if (strcmp(atual->dados->rg, rg) == 0)
//     {
//       printf("Nome: %s\n", atual->dados->nome);
//       printf("Idade: %d\n", atual->dados->idade);
//       printf("RG: %s\n", atual->dados->rg);
//       printf("Data de entrada: %02d/%02d/%04d\n", atual->dados->entrada->dia, atual->dados->entrada->mes, atual->dados->entrada->ano);
//       return;
//     }
//     atual = atual->proximo;
//   }
//   printf("Paciente nao encontrado\n");
// }

// Função para procurar paciente cadastrado pelo rg
// void


// TESTANDO

// // Função para criar um objeto cJSON a partir de uma estrutura de dados genérica
// cJSON* estruturaJson(void* data, const char* campo[], const char* tipo[]) {
//   // Função auxiliar para adicionar um campo ao objeto JSON
//     cJSON* obj = cJSON_CreateObject();

//     // Macro para adicionar um campo ao objeto JSON
//     for (int i = 0; campo[i] != NULL; i++) {
//       // Adiciona o campo ao objeto JSON
//         if (strcmp(tipo[i], "int") == 0) {
//             // Adiciona um campo do tipo inteiro
//             ADD_FIELD(obj, campo[i], Number, *((int*)data + i));
//         } else if (strcmp(tipo[i], "char*") == 0) {
//           // Adiciona um campo do tipo string
//             ADD_FIELD(obj, campo[i], String, *((char**)data + i));
//         // Adiciona um campo do tipo Data
//         } else if (strcmp(tipo[i], "Data") == 0) {
//             // Pega o ponteiro para a estrutura Data
//             Data* data_ptr = (Data*)((char*)data + i * sizeof(char*));
//             // Cria um objeto JSON para a estrutura Data
//             cJSON* data_obj = cJSON_CreateObject();
//             // Adiciona os campos da estrutura Data ao objeto JSON
//             ADD_FIELD(data_obj, "dia", Number, data_ptr->dia);
//             ADD_FIELD(data_obj, "mes", Number, data_ptr->mes);
//             ADD_FIELD(data_obj, "ano", Number, data_ptr->ano);
//             // Adiciona o objeto JSON da estrutura Data ao objeto JSON principal
//             cJSON_AddItemToObject(obj, campo[i], data_obj);
//         } else {
//             // Tratar outros tipos de dados aqui
//             printf("Tipo de dado não suportado: %s\n", tipo[i]);
//         }
//     }
//     // Retorna o objeto JSON criado
//     return obj;
// }

// // Função para ler um arquivo JSON e popular uma estrutura
// void jsonEstrutura(const char* arquivo, void* estrutura, const char* campo[], const char* tipo[]) {
//     FILE* fp = fopen(arquivo, "r");
//     if (!fp) {
//         perror("Erro ao abrir o arquivo");
//         return;
//     }

//     fseek(fp, 0, SEEK_END);
//     long fsize = ftell(fp);
//     fseek(fp, 0, SEEK_SET);

//     char* jsonString = (char*)malloc(fsize + 1);
//     fread(jsonString, 1, fsize, fp);
//     fclose(fp);
//     jsonString[fsize] = 0;

//     cJSON* root = cJSON_Parse(jsonString);
//     if (!root) {
//         printf("Erro ao analisar o JSON\n");
//         free(jsonString);
//         return;
//     }

//     // Assumindo que o JSON raiz contém um único objeto representando a estrutura
//     estruturaJson(estrutura, campo, tipo);

//     cJSON_Delete(root);
//     free(jsonString);
// }


// COMPLEMENTAR A PILHA E A FILA

// void enfileirar(Fila *fila, int valor) {
//     // ... código para enfileirar
//     empilhar(&pilha_operacoes, ENFILEIRAR);
// }

// void desenfileirar(Fila *fila) {
//     // ... código para desenfileirar
//     empilhar(&pilha_operacoes, DESENFILEIRAR);
// }

// void desfazer() {
//     if (pilha_operacoes != NULL) {
//         Operacao operacao = topo(&pilha_operacoes);
//         desempilhar(&pilha_operacoes);

//         if (operacao == ENFILEIRAR) {
//             // Desfazer enfileiramento (desenfileirar)
//             desenfileirar(&fila);
//         } else {
//             // Desfazer desenfileiramento (enfileirar o último elemento removido)
//             // ... implemtar
//         }
//     } else {
//         printf("Não há operações para desfazer.\n");
//     }
// }

// void empilhar(SPilha **topo, Operacao operacao) {
//     SPilha *novo = (SPilha*) malloc(sizeof(SPilha));
//     novo->operacao = operacao;
//     novo->proximo = *topo;
//     *topo = novo;
// }

// void desempilhar(SPilha **topo) {
//     if (*topo != NULL) {
//         SPilha *temp = *topo;
//         *topo = (*topo)->proximo;
//         free(temp);
//     }
// }

// Operacao topo(SPilha *topo) {
//     if (topo == NULL) {
//         // Pilha vazia, retornar um valor inválido ou gerar uma exceção
//         return -1; // Por exemplo
//     }
//     return topo->operacao;
// }


// Lista encadeada para armazenar os registros de pacientes, porém deve ser feito com pilha.
// typedef struct Pilha
// {
//      Operacao operacao;
//      struct Pilha *proximo;
// } Pilha;


LIMPEZA GERAL, MUDANDO O FOCO

// Estruturas pra ficar mais facil de ver
// Registros de pacientes
// typedef struct
// {
//      int dia;
//      int mes;
//      int ano;
// } Data;

// typedef struct
// {
//      // char nome[50];
//      char nome;
//      int idade;
//      // char rg[10];
//      char rg;
//      Data *entrada;
// } Registro;

// // Item de menu: Cadastrar em uma LDE
// typedef struct ELista
// {
//      Registro *dados;
//      struct ELista *proximo;
// } ELista;

// typedef struct
// {
//      ELista *inicio;
//      int qtde;
// } Lista;

// // Item de menu: Atendimento em uma Fila
// typedef struct EFila
// {
//      Registro *dados;
//      struct EFila *proximo;
// } EFila;

// typedef struct
// {
//      EFila *head;
//      EFila *tail;
//      int qtde;
// } Fila;

// // Item de menu: Pesquisa
// typedef struct EABB
// {
//      Registro *dados;
//      // Filhos esquerdo e direito
//      struct EABB *esq;
//      struct EABB *dir;
// } EABB;

// typedef struct
// {
//      EABB *raiz;
//      int qtde;
// } ABB;

// Se der errado aqui mudo pra um 
// typedef enum
// {
//      ENFILEIRAR,
//      DESENFILEIRAR
// } Operacao;

// // Pilha dinamica usa anterior e próximo
// typedef struct Celula
// {
//     Operacao operacao;
//     struct Celula *proximo;
//     struct Celula *anterior;
// } Celula;

// ou 


// // Pilha dinamica usa anterior e próximo
// typedef struct Celula
// {
//      // 1 para enfileirar, 2 para desinfileirar
//      int operacao;
// //     Operacao operacao;
//     struct Celula *proximo;
//     struct Celula *anterior;
// } Celula;

// // Pilha (Stack) para armazenar as operações de enfileirar e desenfileirar
// typedef struct
// {
//     Celula *topo;
//     int qtd;
// } Pilha;

// typedef struct
// {
//      Lista *lista;
//      Fila *fila;
//      ABB *abb;
//      Pilha *pilha;
// } Dados;

// Funções para inicializar as estruturas de dados com base em arquivos JSON

// Função genérica para serializar uma estrutura
cJSON *estruturaToJson(void *data, const char *campos[], const char *tipos[])
{
  cJSON *obj = cJSON_CreateObject();
  int i = 0;
  while (campos[i] != NULL)
  {
    switch (tipos[i][0])
    {
    case 'i': // int
      cJSON_AddNumberToObject(obj, campos[i], *((int *)data + i));
      break;
    case 'c': // char*
      cJSON_AddStringToObject(obj, campos[i], *((char **)data + i));
      break;
    case 'D': // Data
    {
      Data *data_ptr = (Data *)((char *)data + i * sizeof(char *));
      cJSON *data_obj = cJSON_CreateObject();
      cJSON_AddNumberToObject(data_obj, "dia", data_ptr->dia);
      cJSON_AddNumberToObject(data_obj, "mes", data_ptr->mes);
      cJSON_AddNumberToObject(data_obj, "ano", data_ptr->ano);
      cJSON_AddItemToObject(obj, campos[i], data_obj);
    }
    break;
    case 'L': // ELista*
      cJSON_AddItemToObject(obj, campos[i], estruturaToJson(*((ELista **)data + i), campos, tipos));
      break;
    case 'F': // EFila*
      cJSON_AddItemToObject(obj, campos[i], estruturaToJson(*((EFila **)data + i), campos, tipos));
      break;
    case 'A': // EABB*
      cJSON_AddItemToObject(obj, campos[i], estruturaToJson(*((EABB **)data + i), campos, tipos));
      break;
    // case 'P': // Pilha*
    //   cJSON_AddItemToObject(obj, campos[i], estruturaToJson(*((Pilha **)data + i), campos, tipos));
    //   break;
    // ... outros tipos
    default:
      printf("Tipo de dado não suportado: %s\n", tipos[i]);
    }
    i++;
  }
  return obj;
}

// Função genérica para desserializar uma estrutura
void jsonParaEstrutura(const cJSON *obj, void *estrutura, const char *campos[], const char *tipos[])
{
  int i = 0;
  while (campos[i] != NULL)
  {
    cJSON *item = cJSON_GetObjectItem(obj, campos[i]);
    if (item)
    {
      switch (tipos[i][0])
      {
      case 'i': // int
        *((int *)estrutura + i) = item->valueint;
        break;
      case 'c': // char*
        *((char **)estrutura + i) = strdup(item->valuestring);
        break;
      case 'D': // Data
      {
        Data *data_ptr = (Data *)((char *)estrutura + i * sizeof(char *));
        cJSON *dia = cJSON_GetObjectItem(item, "dia");
        cJSON *mes = cJSON_GetObjectItem(item, "mes");
        cJSON *ano = cJSON_GetObjectItem(item, "ano");
        data_ptr->dia = dia->valueint;
        data_ptr->mes = mes->valueint;
        data_ptr->ano = ano->valueint;
      }
      break;
      case 'L': // ELista*
      {
        ELista **lista = (ELista **)((char *)estrutura + i * sizeof(char *));
        *lista = (ELista *)malloc(sizeof(ELista));
        jsonParaEstrutura(item, (*lista)->dados, campos, tipos);
        (*lista)->proximo = NULL;
      }
      break;
      case 'F': // EFila*
      {
        EFila **fila = (EFila **)((char *)estrutura + i * sizeof(char *));
        *fila = (EFila *)malloc(sizeof(EFila));
        jsonParaEstrutura(item, (*fila)->dados, campos, tipos);
        (*fila)->proximo = NULL;
      }
      break;
      case 'A': // EABB*
      {
        EABB **abb = (EABB **)((char *)estrutura + i * sizeof(char *));
        *abb = (EABB *)malloc(sizeof(EABB));
        jsonParaEstrutura(item, (*abb)->dados, campos, tipos);
        (*abb)->esq = NULL;
        (*abb)->dir = NULL;
      }
      break;
      case 'P': // Pilha*
      {
        // ARRUMAR A PILHA EM TUDO
        // typedef struct Celula
        // {
        //   Operacao operacao;
        //   struct Celula *proximo;
        //   struct Celula *anterior;
        // } Celula;

        // // Pilha (Stack) para armazenar as operações de enfileirar e desenfileirar
        // typedef struct
        // {
        //   Celula *topo;
        //   int qtd;
        // } Pilha;


        // Pilha **pilha = (Pilha **)((char *)estrutura + i * sizeof(char *));
        // *pilha = (Pilha *)malloc(sizeof(Pilha));
        // (*pilha)->topo = NULL;
        // (*pilha)->qtd = 0;
        // cJSON *celula = item;
        // while (celula)
        // {
        //   Celula *nova = (Celula *)malloc(sizeof(Celula));
        //   nova->operacao = celula->valueint;
        //   nova->proximo = (*pilha)->topo;
        //   (*pilha)->topo = nova;
        //   (*pilha)->qtd++;
        //   celula = celula->next;
        // }
      }
      break;
        // ... outros tipos
      }
    }
    else
    {
      printf("Campo '%s' não encontrado no JSON\n", campos[i]);
    }
    i++;
  }
}

// Função para serializar toda a estrutura de dados
cJSON *serializarTudo(Dados *dados)
{
  cJSON *root = cJSON_CreateObject();

  // Definir os campos e tipos de cada estrutura
  const char *camposLista[] = {"inicio", "qtde", NULL};
  const char *tiposLista[] = {"ELista*", "int", NULL};
  const char *camposFila[] = {"head", "tail", "qtde", NULL};
  const char *tiposFila[] = {"EFila*", "EFila*", "int", NULL};
  const char *camposABB[] = {"raiz", "qtde", NULL};
  const char *tiposABB[] = {"EABB*", "int", NULL};
  // const char *camposPilha[] = {"operacao", "proximo", NULL};
  // const char *tiposPilha[] = {"Operacao", "Pilha*", NULL};

  // ... e assim por diante para as outras possiveis estruturas

  cJSON_AddItemToObject(root, "lista", estruturaToJson(dados->lista, camposLista, tiposLista));
  cJSON_AddItemToObject(root, "fila", estruturaToJson(dados->fila, camposFila, tiposFila));
  cJSON_AddItemToObject(root, "abb", estruturaToJson(dados->abb, camposABB, tiposABB));
  // cJSON_AddItemToObject(root, "pilha", estruturaToJson(dados->pilha, camposPilha, tiposPilha));
  // ...

  return root;
}

// Função para desserializar toda a estrutura de dados
void desserializarTudo(const char *arquivo, Dados *dados)
{
  // ... (lógica similar à função serializarTudo, mas no sentido inverso)
  FILE *fp = fopen(arquivo, "r");
  if (!fp)
  {
    perror("Erro ao abrir o arquivo");
    return;
  }

  fseek(fp, 0, SEEK_END);
  long fsize = ftell(fp);
  fseek(fp, 0, SEEK_SET);

  char *jsonString = (char *)malloc(fsize + 1);
  fread(jsonString, 1, fsize, fp);
  fclose(fp);
  jsonString[fsize] = 0;

  cJSON *root = cJSON_Parse(jsonString);
  if (!root)
  {
    printf("Erro ao analisar o JSON\n");
    free(jsonString);
    return;
  }

  // Definir os campos e tipos de cada estrutura
  const char *camposLista[] = {"inicio", "qtde", NULL};
  const char *tiposLista[] = {"ELista*", "int", NULL};
  const char *camposFila[] = {"head", "tail", "qtde", NULL};
  const char *tiposFila[] = {"EFila*", "EFila*", "int", NULL};
  const char *camposABB[] = {"raiz", "qtde", NULL};
  const char *tiposABB[] = {"EABB*", "int", NULL};
  // const char *camposPilha[] = {"operacao", "proximo", NULL};
  // const char *tiposPilha[] = {"Operacao", "Pilha*", NULL};
  // ... e assim por diante para as outras possiveis estruturas

  jsonParaEstrutura(root, dados->lista, camposLista, tiposLista);
  jsonParaEstrutura(root, dados->fila, camposFila, tiposFila);
  jsonParaEstrutura(root, dados->abb, camposABB, tiposABB);
  // jsonParaEstrutura(root, dados->pilha, camposPilha, tiposPilha);
  // ...

  cJSON_Delete(root);
  free(jsonString);
}

Funcoes h limpeza também
// Para adicionar um campo ao JSON, basta adicionar uma linha no formato ADD_FIELD(obj, name, type, value)
// #define ADD_FIELD(obj, name, type, value) \
//     cJSON_Add##type##ToObject(obj, name, value)

// #define GET_FIELD(obj, name, type) \
//     cJSON_GetObjectItem(obj, name)->value##type


void cadastrarPaciente(Lista *lista);
void consultarPaciente(Lista *lista);

// void imprimirRegistro(Registro *r);

// cJSON* estruturaJson(void* data, const char* campo[], const char* tipo[]);
// void jsonEstrutura(const char* arquivo, void* estrutura, const char* campo[], const char* tipo[]);


// Pilha para armazenar operações (enfileirar e desenfileirar), para desfazer
// typedef enum
// {
//      ENFILEIRAR,
//      DESENFILEIRAR
// } Operacao;

limpeza do menu


    //   if (cod != 0)
    //   {
    //     printf("Erro ao salvar arquivo!\n");
    //   }

    // TESTE DE JSON

    //     printf("Testando \n");
    //     Registro registro = {"João da Silva", 30, "123456789", 0};
    //     registro.entrada = (Data*)malloc(sizeof(Data));
    //     registro.entrada->dia = 15;
    //     registro.entrada->mes = 3;
    //     registro.entrada->ano = 2023;
    //     printf("Testando 1\n");
    //     const char *campos_registro[] = {"nome", "idade", "rg", "entrada.dia", "entrada.mes", "entrada.ano", NULL};
    //     const char *tipos_registro[] = {"char*", "int", "char*", "Data", "Data", "Data", NULL};
    //     printf("Testando 2\n");
    //     cJSON *json = estruturaJson(&registro, campos_registro, tipos_registro);
    //     printf("Testando 3\n");
    //     char *string_json = cJSON_Print(json);
    //     printf("Testando 4\n");
    //     FILE *fp = fopen("dados.json", "w");
    //     printf("Testando 5\n");
    //     fwrite(string_json, strlen(string_json), 1, fp);
    //     printf("Testando 6\n");
    //     fclose(fp);
    //     printf("Testando 7\n");
    //     cJSON_Delete(json);
    //     free(string_json);
    //     printf("Testando 8\n");

    // Registro nova_registro;
    // jsonEstrutura("dados.json", &nova_registro, campos_registro, tipos_registro);
    // printf("Testando\n");
    // for (int i = 0; campos_registro[i] != NULL; i++)
    // {
    //     printf("%s: ", campos_registro[i]);
    //     if (tipos_registro[i][0] == 'c')
    //     {
    //         printf("%s\n", *((char **)&nova_registro + i));
    //     }
    //     else if (tipos_registro[i][0] == 'i')
    //     {
    //         printf("%d\n", *((int *)&nova_registro + i));
    //     }
    //     else if (tipos_registro[i][0] == 'D')
    //     {
    //         Data *data = (Data *)((char *)&nova_registro + i);
    //         printf("%d/%d/%d\n", data->dia, data->mes, data->ano);
    //     }
    // }
    // printf("Testando\n");


        // IDEIA DE COMO USAR O JSON
    // // ... (criar instâncias das estruturas e popular os dados)

    // // Serializar para JSON
    // Dados dados;
    // // ... (popular a estrutura dados)
    // cJSON *root = serializarTudo(&dados);
    // // ... (escrever em um arquivo)

    // // Desserializar de um arquivo
    // Dados novosDados;
    // desserializarTudo("dados.json", &novosDados);
    // // ... (usar os dados desserializados)

    // TESTANDO JSON

    // Criar instâncias das estruturas e popular os dados
    // Dados dados;
    // dados.lista = criarLista(); // Função para criar e popular a lista
    // dados.fila = criarFila();   // Função para criar e popular a fila
    // dados.abb = criarABB();     // Função para criar e popular a ABB
    // dados.pilha = criarPilha(); // Função para criar e popular a pilha

    // // Serializar para JSON
    // cJSON *root = serializarTudo(&dados);
    // char *jsonString = cJSON_Print(root);

    // // Escrever em um arquivo
    // FILE *fp = fopen("dados.json", "w");
    // if (fp) {
    //     fprintf(fp, "%s", jsonString);
    //     fclose(fp);
    //     printf("Dados serializados com sucesso para dados.json\n");
    // } else {
    //     perror("Erro ao abrir o arquivo");
    // }

    // cJSON_Delete(root);
    // free(jsonString);

    // // Limpar as estruturas existentes (opcional)
    // destruirLista(dados.lista);
    // destruirFila(dados.fila);
    // destruirABB(dados.abb);
    // destruirPilha(dados.pilha);

    // // Ler o JSON e desserializar
    // Dados novosDados;
    // desserializarTudo("dados.json", &novosDados);

    // // Imprimir os dados desserializados para verificar
    // imprimirLista(novosDados.lista);
    // imprimirFila(novosDados.fila);
    // imprimirABB(novosDados.abb);
    // imprimirPilha(novosDados.pilha);

    // // Liberar a memória das estruturas desserializadas
    // destruirLista(novosDados.lista);
    // destruirFila(novosDados.fila);
    // destruirABB(novosDados.abb);
    // destruirPilha(novosDados.pilha);



    //   int cod;
    // Ia ser usado para salvar os arquivos em txt, mas irei tentar fazer em json
    //   char arquivo[] = "arquivo,";
    //   char exportado[] = "-";
    //   ArquivosPacientes lt;

    //   cod = carregarLista(&lt, arquivo);
    //   if (cod == 1)
    //   {
    //     lt.qtd = 0;
    //   }



    
// // Atualizar dados de paciente
// void atualizar(Lista *lista, char *nome){
//   ELista *atual = lista->inicio;
//   while(atual != NULL){
//     if(strcmp(atual->dados->nome, nome) == 0){
//       printf("Nome: ");
//       scanf("%s", atual->dados->nome);
//       printf("Idade: ");
//       scanf("%d", &atual->dados->idade);
//       printf("RG: ");
//       scanf("%s", atual->dados->rg);
//       atual->dados->entrada = malloc(sizeof(Data));
//       printf("Data de entrada: ");
//       scanf("%d/%d/%d", &atual->dados->entrada->dia, &atual->dados->entrada->mes, &atual->dados->entrada->ano);
//       return;
//     }
//     atual = atual->proximo;
//   }
//   printf("Paciente nao encontrado\n");
// }

// // Atualizar dados de paciente por RG
// void atualizarRG(Lista *lista, char *rg){
//   ELista *atual = lista->inicio;
//   while(atual != NULL){
//     if(strcmp(atual->dados->rg, rg) == 0){
//       printf("Nome: ");
//       scanf("%s", atual->dados->nome);
//       printf("Idade: ");
//       scanf("%d", &atual->dados->idade);
//       printf("RG: ");
//       scanf("%s", atual->dados->rg);
//       atual->dados->entrada = malloc(sizeof(Data));
//       printf("Data de entrada: ");
//       scanf("%d/%d/%d", &atual->dados->entrada->dia, &atual->dados->entrada->mes, &atual->dados->entrada->ano);
//       return;
//     }
//     atual = atual->proximo;
//   }
//   printf("Paciente nao encontrado\n");
// }

// // Atualizar dados de paciente escolhendo por nome ou RG e chamando a função correspondente
// void atualizarPaciente(Lista *lista){
//   int opcao;
//   printf("Atualizar por:\n");
//   printf("1 - Nome\n");
//   printf("2 - RG\n");
//   printf("Digite a opcao desejada: ");
//   scanf("%d", &opcao);
//   if(opcao == 1){
//     char nome[50];
//     printf("Nome: ");
//     scanf("%s", nome);
//     atualizar(lista, nome);
//   }else if(opcao == 2){
//     char rg[10];
//     printf("RG: ");
//     scanf("%s", rg);
//     atualizarRG(lista, rg);
//   }else{
//     printf("Opcao invalida\n");
//   }
// }

// Atualizar dados de paciente (por nome ou rg), printar dados do usuario e escolher o que deseja atualizar.
// void atualizarPaciente(Lista *lista){
//   printf("Opções:\n");
//   printf("1 - Atualizar por nome\n");
//   printf("2 - Atualizar por RG\n");
//   printf("Digite a opcao desejada: ");
//   int opcao;
//   scanf("%d", &opcao);

//   if(opcao == 1){
//     char nome[50];
//     printf("Nome: ");
//     scanf("%s", nome);
//     ELista *atual = lista->inicio;
//     while(atual != NULL){
//       if(strcmp(atual->dados->nome, nome) == 0){
//         printf("Nome: %s\n", atual->dados->nome);
//         printf("Idade: %d\n", atual->dados->idade);
//         printf("RG: %s\n", atual->dados->rg);
//         printf("Data de entrada: %d/%d/%d\n", atual->dados->entrada->dia, atual->dados->entrada->mes, atual->dados->entrada->ano);
//         int opcao;
//         printf("Atualizar:\n");
//         printf("1 - Nome\n");
//         printf("2 - Idade\n");
//         printf("3 - RG\n");
//         printf("4 - Data de entrada\n");
//         printf("Digite a opcao desejada: ");
//         scanf("%d", &opcao);
//         if(opcao == 1){
//           printf("Nome: ");
//           scanf("%s", atual->dados->nome);
//         }else if(opcao == 2){
//           printf("Idade: ");
//           scanf("%d", &atual->dados->idade);
//         }else if(opcao == 3){
//           printf("RG: ");
//           scanf("%s", atual->dados->rg);
//         }else if(opcao == 4){
//           atual->dados->entrada = malloc(sizeof(Data));
//           printf("Data de entrada: ");
//           scanf("%d/%d/%d", &atual->dados->entrada->dia, &atual->dados->entrada->mes, &atual->dados->entrada->ano);
//         }else{
//           printf("Opcao invalida\n");
//         }
//         return;
//       }
//       atual = atual->proximo;
//     }
//     printf("Paciente nao encontrado\n");
//   }else if(opcao == 2){
//     char rg[10];
//     printf("RG: ");
//     scanf("%s", rg);
//     ELista *atual = lista->inicio;
//     while(atual != NULL){
//       if(strcmp(atual->dados->rg, rg) == 0){
//         printf("Nome: %s\n", atual->dados->nome);
//         printf("Idade: %d\n", atual->dados->idade);
//         printf("RG: %s\n", atual->dados->rg);
//         printf("Data de entrada: %d/%d/%d\n", atual->dados->entrada->dia, atual->dados->entrada->mes, atual->dados->entrada->ano);
//         int opcao;
//         printf("Atualizar:\n");
//         printf("1 - Nome\n");
//         printf("2 - Idade\n");
//         printf("3 - RG\n");
//         printf("4 - Data de entrada\n");
//         printf("Digite a opcao desejada: ");
//         scanf("%d", &opcao);
//         if(opcao == 1){
//           printf("Nome: ");
//           scanf("%s", atual->dados->nome);
//         }else if(opcao == 2){
//           printf("Idade: ");
//           scanf("%d", &atual->dados->idade);
//         }else if(opcao == 3){
//           printf("RG: ");
//           scanf("%s", atual->dados->rg);
//         }else if(opcao == 4){
//           atual->dados->entrada = malloc(sizeof(Data));
//           printf("Data de entrada: ");
//           scanf("%d/%d/%d", &atual->dados->entrada->dia, &atual->dados->entrada->mes, &atual->dados->entrada->ano);
//         }else{
//           printf("Opcao invalida\n");
//         }
//         return;
//       }
//       atual = atual->proximo;
//     }
//     printf("Paciente nao encontrado\n");
//   }else{
//     printf("Opcao invalida\n");
//   }
// }


// // Inicializar registro
// Registro *inicializa_registro();
// // Inicializar data
// Data *inicializa_data();
// // Inicializar elemento de lista
// ELista *inicializa_elemento();
// // Inicializar fila
// Fila *inicializaFila();
// // Inicializar elemento de fila
// EFila *inicializa_elemento_fila();
// // Inicializar árvore
// ABB *inicializa_abb();
// // Inicializar elemento de árvore
// EABB *inicializa_elemento_abb();
// // Inicializar pilha
// Pilha *inicializaPilha();
// // Inicializar célula
// Celula *inicializa_celula();
// // Inicializar dados
// Dados *inicializa_dados();


ITENS PARA CONCERTAR DA PESQUISA

// void inserir(ABB *arvore, Registro *dados)
// {
//   EABB *novo = criaVertice(dados);
//   EABB *atual = arvore->raiz;
//   EABB *anterior = NULL;
//   // Se a arvore estiver vazia
//   if (arvore->raiz == NULL)
//   {
//     arvore->raiz = novo;
//     arvore->qtde++;
//   }
//   else
//   {
//     // Enquanto não chegar em uma folha
//     while (atual != NULL)
//     {
//       // Atualiza o anterior
//       anterior = atual;
//       // Se o ano do novo registro for menor que o ano do registro atual
//       if (dados->entrada->ano < atual->dados->entrada->ano)
//       {
//         // Atualiza o atual
//         atual = atual->esq;
//       }
//       // Se o ano do novo registro for maior que o ano do registro atual
//       else
//       {
//         // Atualiza o atual
//         atual = atual->dir;
//       }
//     }
//     // Se o ano do novo registro for menor que o ano do registro anterior
//     if (dados->entrada->ano < anterior->dados->entrada->ano)
//     {
//       // Insere a esquerda
//       anterior->esq = novo;
//     }
//     // Se o ano do novo registro for maior que o ano do registro anterior
//     else
//     {
//       // Insere a direita
//       anterior->dir = novo;
//     }
//     arvore->qtde++;
//   }
// }

// void mostrar_ano(ABB *arvore)
// {
//   EABB *raiz = arvore->raiz;
//   if (raiz != NULL)
//   {
//     mostrar_ano(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrar_ano(raiz->dir);
//   }
//   else
//   {
//     printf("Arvore vazia\n");
//   }
// }

// void mostrar_mes(ABB *arvore)
// {
//   EABB *raiz = arvore->raiz;
//   if (raiz != NULL)
//   {
//     mostrar_mes(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrar_mes(raiz->dir);
//   }
//   else
//   {
//     printf("Arvore vazia\n");
//   }
// }

// void mostrar_dia(ABB *arvore)
// {
//   EABB *raiz = arvore->raiz;
//   if (raiz != NULL)
//   {
//     mostrar_dia(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrar_dia(raiz->dir);
//   }
//   else
//   {
//     printf("Arvore vazia\n");
//   }
// }

// void mostrar_idade(ABB *arvore)
// {
//   EABB *raiz = arvore->raiz;
//   if (raiz != NULL)
//   {
//     mostrar_idade(raiz->esq);
//     printf("----------------------------------------\n");
//     printf("Nome: %s\n", raiz->dados->nome);
//     printf("Idade: %d\n", raiz->dados->idade);
//     printf("RG: %s\n", raiz->dados->rg);
//     printf("Data de entrada: %d/%d/%d\n", raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
//     mostrar_idade(raiz->dir);
//   }
//   else
//   {
//     printf("Arvore vazia\n");
//   }
// }

// void mostrar_ano_ordenado(ABB *arvore)
// {
//   mostrar_ano(arvore->raiz);
// }

// void mostrar_mes_ordenado(ABB *arvore)
// {
//   mostrar_mes(arvore->raiz);
// }

// void mostrar_dia_ordenado(ABB *arvore)
// {
//   mostrar_dia(arvore->raiz);
// }

// void mostrar_idade_ordenado(ABB *arvore)
// {
//   mostrar_idade(arvore->raiz);
// }




void desfazer(Pilha *pilha, Fila *fila, Lista *lista)
{
  printf("Desfazer\n");
  printf("----------------------------------------\n");
  if (pilha->qtd == 0)
  {
    printf("Nao ha operacoes para desfazer\n");
    return;
  }
  int operacao;
  char rg[maxRG];
  // O & é necessário para passar o endereço da variável
  pop(pilha, &operacao, rg);
  if (operacao == 1)
  {
    printf("Desenfileirar\n");
  }
  else if (operacao == 2)
  {
    printf("Enfileirar\n");
  }
  printf("----------------------------------------\n");
  printf("Deseja desfazer a operacao?\n");
  printf("----------------------------------------\n");
  printf("1 - Sim\n");
  printf("2 - Nao\n");
  printf("----------------------------------------\n");
  printf("Digite a opcao desejada: ");
  int opcao;
  scanf("%d", &opcao);
  if (opcao == 1)
  {
    if (operacao == 1)
    {
      // Se a operação for desenfileirar, coloque o paciente de volta na fila na primeira posição (que é a que ele estava antes de ser desenfileirado)

      // Cria uma nova célula
      EFila *nova = criarCelula(pilha->topo->dados);
      // Se a fila estiver vazia
      if (fila->head == NULL)
      {
        fila->head = nova;
        fila->tail = nova;
      }
      else
      {
        // Se a fila não estiver vazia, coloque o paciente na primeira posição
        nova->proximo = fila->head;
        fila->head = nova;
      }
      // printf("Paciente %s", pilha->topo->dados->nome);
      // printf(" adicionado(a) a fila de espera.\n");
      
      // Desenfileira o paciente da pilha
      free(pilha->topo->dados);
      free(pilha->topo);
      pilha->qtd--;
    }
    else if (operacao == 2)
    {
      // Se a operação for enfileirar, retire o ultimo paciente da fila, desenfileirar retira o primeiro paciente
      // EFila *atual = fila->head;
      // EFila *anterior = NULL;
      // while (atual != NULL)
      // {
      //   if (strcmp(atual->dados->rg, rg) == 0)
      //   {
      //     if (anterior == NULL)
      //     {
      //       fila->head = atual->proximo;
      //       free(atual);
      //       fila->qtde--;
      //       break;
      //     }
      //     else
      //     {
      //       anterior->proximo = atual->proximo;
      //       free(atual);
      //       fila->qtde--;
      //       break;
      //     }
      //   }
      //   anterior = atual;
      //   atual = atual->proximo;
      // }
      // printf("Paciente %s", rg);
      // printf(" removido(a) da fila de espera.\n");

      // // Cria uma nova célula
      // Celula *nova = cria_celula(1, pilha->topo->dados);
      // // Se a pilha estiver vazia
      // if (pilha->qtd == 0)
      // {
      //   pilha->topo = nova;
      // }
      // else
      // {
      //   // Se a pilha não estiver vazia, coloque o paciente na primeira posição
      //   nova->proximo = pilha->topo;
      //   pilha->topo = nova;
      // }

      // free(pilha->topo->dados);
      // free(pilha->topo);
      // pilha->qtd--;

      if (fila->tail == NULL)
      {
        printf("Fila já está vazia.\n");
        return;
      }

      EFila *temp = fila->head;
      while (temp->proximo != fila->tail)
      {
        temp = temp->proximo;
      }
      free(fila->tail);
      fila->tail = temp;
      temp->proximo = NULL;
      fila->qtde--;

      free(pilha->topo->dados);
      free(pilha->topo);
      pilha->qtd--;

      printf("Operacao desfeita\n");

      // Adiciona uma nova entrada na pilha com a operação de desenfileirar
      //Celula *nova = cria_celula(1, pilha->topo->dados); // 1 indica a operação de desenfileirar
      //nova->proximo = pilha->topo;
      //pilha->topo = nova;
      //pilha->qtd++;
    }
    else
    {
      printf("Operacao invalida\n");
    }
  }
  else if (opcao == 2)
  {
    push(pilha, operacao, NULL);
  }
  else
  {
    printf("Opcao invalida\n");
  }
}